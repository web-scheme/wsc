;;* Compiler implementation for libraries.
(define-module (compile library)
  #:export (compile-define-library compile-library-body)
  #:use-module (scheme base)
  #:use-module ((srfi srfi-26) #:select (cut))
  #:use-module ((compile) #:select (add-imports
                                    compiled-module
                                    new-empty-module))
  #:use-module ((compile import) #:select (lookup-imports))
  #:use-module ((parse env) #:select (bind-syntax!
                                      lookup-variable-or-builtin
                                      make-env))
  #:use-module ((syntax wrap) #:select (unwrap-all-syntax
                                        unwrap-symbol
                                        unwrap-library-name-part
                                        resolve-s-expression
                                        wrapped-syntax.datum
                                        wrapped-syntax.env))
  #:use-module ((tools) #:select (λ))
  #:use-module ((tools logging) #:select (log-error))
)

;* Validate and compile an import statement.
;*
;* Parameters
;*   import-sets: '[List] of [wrapped syntax](wrapped-syntax) objects
;*                 representing import sets.'
;*   module:       Module being compiled.
;*
;* Result
;*   `#t` on success, or `#f` on failure.
define compile-library-imports(import-sets module)
  unless null?(import-sets)
    let* ((next-set  car(import-sets))
          (imports   lookup-imports(next-set)))
      and imports
          begin
            add-imports(module imports)
            compile-library-imports(cdr(import-sets) module)

define compile-library-export(export-specs module)
  'TODO

define compile-library-begin(statements module)
  'TODO

define library-declaration-syntax
  '((export . export)
    (import . import)
    (begin . begin)
    (include . include)
    (include-ci . include-ci)
    (include-library-declarations . include-library-declarations)
    (cond-expand . cond-expand))

define compile-library-body(name body)
  define module new-empty-module()
  for-each
    λ (declaration)
      define resolved
        apply(resolve-s-expression declaration library-declaration-syntax)
      if resolved
        let ((head car(resolved))
             (tail cdr(resolved)))
          if head
            case head
              (import)
                if null?(tail)
                  log-error("Empty import set" declaration)
                  compile-library-imports(tail module)
              (export)
                compile-library-export(tail module)
              (begin)
                compile-library-begin(tail module)
              else
                ;; The "declaration" is an s-expression, but not valid.
                log-error("Invalid library declaration" declaration)
            log-error("Unbound variable"
                      car(wrapped-syntax.datum(declaration)))
        ;; The "declaration" is *not* an s-expression.
        log-error("Invalid library declaration" declaration)
    body
  module

;* Compile a library definition into a [WASM module](compiled-module).
;*
;* Parameters
;*   name-and-body:  List containing at least one item.
;*
;* Result
;*   Compiled [WASM module](compiled-module).
define compile-define-library(name-and-body)
  ;; [https://web-scheme.org/r7rs-small.pdf#subsection.7.1.7]
  define wrapped-name car(name-and-body)
  define name wrapped-syntax.datum(wrapped-name)
  call/cc
    λ (bail)
      if list?(name)
        compile-library-body(
          map((cut unwrap-library-name-part <> bail) name)
          cdr(name-and-body))
        bail(log-error("Library name must be a list" wrapped-name))
