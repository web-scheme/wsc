;;* TODO
(define-module (compile)
  #:export (add-imports
            compile-modules
            compiled-module
            compiled-module:new
            new-empty-module)
  #:use-module (scheme base)
  #:use-module ((compile import) #:select (wasm-import))
  #:use-module ((compile library) #:select (compile-define-library))
  #:use-module ((syntax wrap) #:select (unwrap-symbol
                                        switch-s-expr
                                        wrapped-syntax.datum))
  #:use-module ((tools logging) #:select (log-error))
)

;* Self-contained WASM module.
define-record-type compiled-module
  compiled-module:new(imports exports)
  compiled-module?
  ;* List of [imports](wasm-import).
  imports compiled-module.imports compiled-module.set-imports!
  ;* List of [exports](wasm-export).
  exports compiled-module.exports compiled-module.set-exports!
  ;* List of [functions](wasm-function).
  functions compiled-module.functions compiled-module.set-functions!

;* Return a new, empty [module](compiled-module).
define new-empty-module()
  compiled-module:new('() '())

;; TODO: This possibly only exists because exporting `compiled-module.set-imports!`
;;       and `compiled-module.imports` is wonky in Guile. Consider refactoring.
define add-imports(module imports)
  ;; TODO: `append` unnecessarily allocates a new list. Optimize.
  compiled-module.set-imports!(
    module
    append(imports
           compiled-module.imports(module)))

;* Compile top-level syntax (a datum with no parent).
;*
;* Parameters
;*   syntax: '[wrapped syntax](wrapped-syntax) object'
;*
;* Result
;*   Either a [module](compiled-module),
;*   or a TODO
define compile-top-level(syntax)
  switch-s-expr syntax head tail '()
    'define
      if null?(tail)
        log-error("Empty definition" syntax)
        1  ; TODO
    'define-library
      if null?(tail)
        log-error("Empty library definition" syntax)
        compile-define-library(tail)
    'define-syntax
      if null?(tail)
        log-error("Empty syntax definition" syntax)
        3  ; TODO
    OTHER
      'TODO
    UNBOUND
      log-error("Unbound variable" car(wrapped-syntax.datum(syntax)))
    ATOM
      set! resolved unwrap-symbol(syntax)
      if resolved
        5  ; TODO
        6  ; TODO
    (THEN)

;* Compile a list of top-level syntax.
;*
;* Parameters
;*   wrapped-data:  List of [wrapped syntax](wrapped-syntax) objects.
;*
;* Result
;*   List of [modules](compiled-module),
;*   where the head of the list is an executable module
;*   comprised of the Scheme code not enclosed in a library,
;*   and any subsequent modules are importable libraries.
define compile-modules(wrapped-data)
  map(compile-top-level wrapped-data)
