;;* Definition of wrapped syntax objects.
(define-module (syntax wrap)
  #:export (wrapped-syntax wrapped-syntax:new wrapped-syntax?
            wrapped-syntax.datum wrapped-syntax.set-datum!
            wrapped-syntax.env wrapped-syntax.filename
            wrapped-syntax.line wrapped-syntax.column wrapped-syntax.prev
            unwrap-all-syntax unwrap-symbol resolve-s-expression
            unwrap-library-name-part
            fake-wrap)
  #:use-module (scheme base)
  #:use-module ((parse env) #:select (env env-new env.bindings lookup-variable-or-builtin))
  #:use-module ((tools) #:select (map-improper))
  #:use-module ((tools logging) #:select (log-error))
)

;* A datum representing an expression in a Scheme program,
;* with extra metadata attached or "wrapped around it",
;* such as source file name and line number.
define-record-type wrapped-syntax
  wrapped-syntax:new(datum env filename line column prev)
  wrapped-syntax?
  ;* Wrapped object.
  datum wrapped-syntax.datum wrapped-syntax.set-datum!
  ;* [Environment](env) in which `datum` exists.
  env wrapped-syntax.env
  ;* Original [filename](string) in which `datum` appeared.
  filename wrapped-syntax.filename
  ;* Line [number](integer) of original appearance.
  line wrapped-syntax.line
  ;* Column [number](integer) of original appearance.
  column wrapped-syntax.column
  ;* Previous version of the [wrapped object](wrapped-syntax) if macro expansion occurred.
  prev wrapped-syntax.prev

;; Return fake wrapped syntax objects as a stopgap until a real parser is implemented.
define fake-wrap(datum env filename)
  ;; Use an auxiliary function to form a closure around `env` and `filename`.
  define fake-wrap-aux(datum)
    cond
      eof-object?(datum)  datum  ; Terminating condition for `collect-list` in `(tools)`.
      pair?(datum)        wrapped-syntax:new(
                            map-improper(fake-wrap-aux datum)
                            env filename 4 20 '())
      vector?(datum)      wrapped-syntax:new(
                            vector-map(fake-wrap-aux datum)
                            env filename 4 20 '())
      else                wrapped-syntax:new(
                            datum
                            env filename 4 20 '())
  fake-wrap-aux(datum)

;* Recursively unwrap a wrapped syntax object.
define unwrap-all-syntax(syntax)
  define datum wrapped-syntax.datum(syntax)
  cond
    pair?(datum)    map-improper(unwrap-all-syntax datum)
    vector?(datum)  vector-map(unwrap-all-syntax datum)
    else            datum

;* Try to unwrap a symbol.
;*
;* Parameters
;*   syntax: '[wrapped syntax](wrapped-syntax) object'
;*
;* Result
;*   The symbol value, or `#f` if `syntax` does not directly wrap a symbol.
define unwrap-symbol(syntax)
  define datum wrapped-syntax.datum(syntax)
  and symbol?(datum)
      datum

;* Try to partially unwrap an s-expression, after all user macros have been expanded.
;*
;* Parameters
;*   syntax:            '[wrapped syntax](wrapped-syntax) object'
;*   override-bindings:  Overriding [bindings](env.bindings) for identifier resolution;
;*                       useful for resolving built-in syntax in particular contexts.
;*
;* Result
;*   If `syntax` wraps an s-expression, return a list where the head is either
;*
;*   - a [variable reference](location) object if `syntax`'s head is bound to a variable
;*   - a [symbol] if it's bound to built-in syntax
;*   - `#f` if it's not bound to anything
;*
;*   and the tail is the untouched tail of `syntax`.
;*   Otherwise, return `#f`.
define resolve-s-expression(syntax . override-bindings)
  define datum    wrapped-syntax.datum(syntax)
  define head-id  (and pair?(datum)
                       unwrap-symbol(car(datum)))
  and head-id
      cons(
        lookup-variable-or-builtin(
          env-new(override-bindings wrapped-syntax.env(car(datum)))
          head-id)
        cdr(datum))

;* Unwrap and validate a component of a library name,
;* which must be either a [symbol] or a non-negative [integer].
;*
;* Parameters
;*   wrapped-part: '[Wrapped syntax](wrapped-syntax) object.'
;*   bail:          Bailing [function] invoked if `wrapped-part` is invalid,
;*                  passing the single argument `#f`.
;*
;* Result
;*   The unwrapped component, or the result of `bail` on failure.
define unwrap-library-name-part(wrapped-part bail)
  define part wrapped-syntax.datum(wrapped-part)
  if {symbol?(part) or {exact-integer?(part) and {part >= 0}}}
    part
    bail(
      log-error(
        "Library name must comprise only identifiers and exact non-negative integers"
        wrapped-part))
